<!DOCTYPE html>
<html lang="he" dir="rtl">

<head>
    <meta charset="UTF-8">
    <title>מסך ראשי - פייק מייקר</title>
    <script src="/socket.io/socket.io.js"></script>
    <!-- Custom Fonts -->
    <link rel="stylesheet" href="styles.css">
</head>

<body class="host-body">

    <div class="header">
        <div class="header-top-border"></div>
        <div class="header-content">
            <div class="logo">פייק מייקר</div> <!-- Logo Top Right -->

            <!-- Header Info Widget (Top Left) -->
            <!-- Header Info Widget (Top Left) -->
            <div class="header-info-widget" id="header-info">
                <!-- Right Column: Time & Weather -->
                <div class="header-column col-time-weather">
                    <div class="header-time" id="clock-time">--:--</div>
                    <div class="header-weather" id="weather-info">טוען מזג אוויר...</div>
                </div>

                <!-- Left Column: Dates -->
                <div class="header-column col-dates">
                    <div class="header-date-gregorian" id="date-gregorian">--/--/----</div>
                    <div class="header-date-hebrew" id="date-hebrew">...</div>
                </div>
            </div>
        </div>

        <script>
            // Header Info Logic
            async function updateHeaderInfo() {
                const now = new Date();

                // Time
                document.getElementById('clock-time').textContent = now.toLocaleTimeString('he-IL', { hour: '2-digit', minute: '2-digit' });

                // Gregorian Date
                document.getElementById('date-gregorian').textContent = now.toLocaleDateString('he-IL', { day: '2-digit', month: '2-digit', year: 'numeric' });

                // Hebrew Date (Fetch from Hebcal API for reliability)
                try {
                    const y = now.getFullYear();
                    const m = now.getMonth() + 1;
                    const d = now.getDate();
                    // Hebcal Converter API
                    const response = await fetch(`https://www.hebcal.com/converter?cfg=json&gy=${y}&gm=${m}&gd=${d}&g2h=1`);
                    const data = await response.json();
                    if (data && data.hebrew) {
                        document.getElementById('date-hebrew').textContent = data.hebrew;
                    }
                } catch (e) {
                    console.error("Hebrew date fetch failed", e);
                    // Fallback
                    const options = { calendar: 'hebrew', day: 'numeric', month: 'long', year: 'numeric' };
                    document.getElementById('date-hebrew').textContent = new Intl.DateTimeFormat('he-IL-u-ca-hebrew', options).format(now);
                }
            }

            async function fetchWeather() {
                try {
                    // Open-Meteo API for Jerusalem
                    const response = await fetch('https://api.open-meteo.com/v1/forecast?latitude=31.7683&longitude=35.2137&current=temperature_2m&timezone=auto');
                    const data = await response.json();

                    if (data && data.current) {
                        const temp = Math.round(data.current.temperature_2m);
                        document.getElementById('weather-info').textContent = `ירושלים: ${temp}°C`;
                    }
                } catch (e) {
                    console.error("Weather fetch failed", e);
                    document.getElementById('weather-info').textContent = "ירושלים: --°C";
                }
            }

            // Init
            updateHeaderInfo();
            setInterval(updateHeaderInfo, 60000); // Update every minute
            fetchWeather();
            setInterval(fetchWeather, 3600000); // Update weather every hour
        </script>
    </div>
    <div class="marquee-container">
        <div class="marquee-content" id="header-marquee">
            טקסט רץ * טקסט רץ * ברוכים הבאים למשחק * טקסט רץ * טקסט רץ *
        </div>
    </div>

    <div class="main-container">
        <!-- Right Column (Player List 1) -->
        <div class="col-side" id="col-right">
            <!-- Slots will be injected here -->
        </div>

        <!-- Center Column (Game Stage) -->
        <div class="col-center" id="game-stage">
            <!-- Default Lobby Content -->
            <div class="lobby-media-placeholder">
                <!-- Could be a logo or video -->
            </div>

            <div class="lobby-content-right">
                <div class="room-code-badge">ABCD</div>
                <h1 class="game-title">פוש מייקר</h1>
                <div class="join-url">http://192.168.67.132:3000/mobile.html :הצטרפו בכתובת</div>
                <button class="action-btn" id="start-btn" style="display:none;" onclick="startGame()">התחל משחק</button>
            </div>
        </div>


    </div>

    <div class="footer">
        <div class="progress-bar" id="footer-progress"></div>
    </div>

    <script>
        const socket = io();
        socket.emit('host_connect');

        // State
        let currentPlayers = [];
        let isGameActive = false;
        const TOTAL_SLOTS = 6;
        const AVATAR_COLORS = ['var(--color-yellow)', 'var(--color-pink)', 'var(--color-green)', 'var(--color-purple)'];

        let previousPlayersMap = {}; // To track score changes

        // Initial Layout Render
        renderPlayerSlots([]);

        socket.on('player_joined', (p) => {
            // Check if player already exists to avoid duplicates
            if (!currentPlayers.some(player => player.id === p.id)) {
                currentPlayers.push(p);
                renderPlayerSlots(currentPlayers);
            }
            document.getElementById('start-btn').style.display = 'block';
        });

        socket.on('update_player_list', (list) => {
            // Store current scores before update for diff calculation later if needed (though results event handles it)
            // But we update currentPlayers here usually for lobby.
            currentPlayers = list;
            renderPlayerSlots(list);
            if (list.length > 0) document.getElementById('start-btn').style.display = 'block';
        });

        function renderPlayerSlots(players, roundScoresMap = null) {
            const rightCol = document.getElementById('col-right');
            if (!rightCol) return;

            rightCol.innerHTML = '';

            let totalNeeded;
            if (isGameActive) {
                totalNeeded = players.length;
            } else {
                totalNeeded = Math.max(TOTAL_SLOTS, players.length);
            }

            for (let i = 0; i < totalNeeded; i++) {
                const player = players[i];
                const container = rightCol;

                const card = document.createElement('div');
                card.className = 'player-card' + (player ? '' : ' empty');

                if (player) {
                    const color = AVATAR_COLORS[i % AVATAR_COLORS.length];
                    let scoreOverlayHtml = '';

                    if (roundScoresMap && roundScoresMap[player.id] !== undefined) {
                        const gain = roundScoresMap[player.id];
                        scoreOverlayHtml = `<div class="score-overlay">+${gain}</div>`;
                    }

                    card.innerHTML = `
                        <div class="player-avatar" style="background-color: ${color};">
                            ${scoreOverlayHtml}
                        </div>
                        <div class="player-info">
                            <div class="player-name">${player.nickname}</div>
                            <div class="player-role">${player.journalisticSpecialty || 'משתתף'}</div>
                        </div>
                    `;
                } else {
                    card.innerHTML = `
                        <div class="player-avatar"></div>
                        <div class="player-info">
                            <div class="player-name">ממתין...</div>
                            <div class="player-role"></div>
                        </div>
                    `;
                }

                container.appendChild(card);
            }
        }

        // --- Game Logic ---

        function setGameContent(html) {
            const stage = document.getElementById('game-stage');
            stage.innerHTML = html;
        }

        function startGame() { socket.emit('host_start_game'); }
        function nextPhase() { socket.emit('host_next_phase'); }

        // --- Timer / Progress Bar ---
        let timerInterval = null;

        function startProgressBar(duration) {
            const bar = document.getElementById('footer-progress');
            if (!bar) return;

            // Force LTR so it shrinks from Right to Left (disappearing 'to' the left)
            bar.parentElement.style.direction = 'ltr';

            // Reset
            bar.style.transition = 'none';
            bar.style.width = '100%';

            if (!duration) return;

            // Force reflow
            void bar.offsetWidth;

            // Start animation with slight delay to ensure browser paints 100% first
            setTimeout(() => {
                bar.style.transition = `width ${duration}ms linear`;
                bar.style.width = '0%';
            }, 50);
        }

        function stopProgressBar() {
            const bar = document.getElementById('footer-progress');
            if (bar) {
                const currentWidth = bar.getBoundingClientRect().width;
                bar.style.transition = 'none';
                bar.style.width = currentWidth + 'px';
            }
        }

        // Writing Phase
        socket.on('host_phase_writing', (data) => {
            isGameActive = true;
            renderPlayerSlots(currentPlayers); // clear overlays
            if (data.duration) startProgressBar(data.duration);

            setGameContent(`
                <h2 class="phase-title">חדר החדשות</h2>
                <h3 style="font-size:1.5rem;">הכתבים עובדים על ידיעות חמות...</h3>
                <div class="lobby-media-placeholder" style="background:transparent; display:flex; font-size:4rem;">
                    ✍️
                </div>
                <div id="submission-count" style="font-size:2rem; font-weight:bold;">0 כתבים סיימו</div>
            `);
        });

        socket.on('update_submission_count', (count) => {
            const el = document.getElementById('submission-count');
            if (el) el.innerText = `${count} כתבים סיימו`;
        });

        // Voting Phase
        socket.on('start_voting_display', (data) => {
            if (data.duration) startProgressBar(data.duration);
            renderPlayerSlots(currentPlayers); // clear overlays

            let optionsHtml = '<div class="voting-grid">';
            data.options.forEach((opt, idx) => {
                optionsHtml += `
                    <div id="option-card-${idx}" class="voting-option">
                        <div>"${opt.text}"</div>
                        <div id="voters-for-${idx}" style="margin-top:10px;"></div>
                    </div>
                `;
            });
            optionsHtml += '</div>';

            setGameContent(`
                <h2 class="phase-title">הצבעה: שאלה ${data.step}/2</h2>
                <h3 style="margin:0 0 20px 0;">${data.question}</h3>
                ${optionsHtml}
            `);
        });

        socket.on('host_player_voted', (name) => {
            // Optional: Show who voted
        });

        // Results
        socket.on('game_over_results', (data) => {
            stopProgressBar();

            // 1. Calculate Score Gains
            // We compare 'currentPlayers' (old state) with 'data.players' (new state)
            const roundScoresMap = {};
            const newPlayersArray = Object.values(data.players);

            // Map old scores
            const oldScores = {};
            currentPlayers.forEach(p => oldScores[p.id] = p.score);

            newPlayersArray.forEach(p => {
                const old = oldScores[p.id] || 0;
                const gain = p.score - old;
                roundScoresMap[p.id] = gain;
            });

            // Update local state
            currentPlayers = newPlayersArray;

            // 2. Render Players with Score Overlays
            renderPlayerSlots(currentPlayers, roundScoresMap);

            // 3. Build Center Column Content
            // Need to find the Truth
            const truthOption = data.options.find(o => o.isReal);
            const missingWord = truthOption ? truthOption.text : "???";

            // Reconstruct full sentence
            // data.original is sent from server (requires restart)
            // data.question is the prompt with ____
            let fullHeadline = missingWord;

            if (data.original) {
                // Highlighting: Replace the missing word in the full text with colored version
                fullHeadline = data.original.replace(missingWord, `<span style="color:var(--color-pink);">${missingWord}</span>`);
            } else if (data.question) {
                // Fallback if server wasn't restarted or data missing
                fullHeadline = data.question.replace(/____/g, `<span style="color:var(--color-pink);">${missingWord}</span>`);
            }

            // Cleanup: Remove any stray underscores that might remain (e.g. from prompt if original was missing)
            // But preserve structure? User requested "remove random underscores".
            // A safer approach: formatting.
            fullHeadline = fullHeadline.replace(/_+/g, '');

            // Random Exclamation
            const exclamations = ["חשיפה!", "לא יאמן!", "מטורף!", "מרגש!", "וואו!", "בלעדי!"];
            const randomExc = exclamations[Math.floor(Math.random() * exclamations.length)];

            // Build Source subtitle
            let sourceHtml = '';
            if (data.source) {
                sourceHtml = `<div style="font-size:1.2rem; color:#888; font-weight:normal; margin-top:5px;">מתוך: ${data.source}</div>`;
            }

            // Build Results Stack
            let stackHtml = '<div class="results-stack">';

            data.options.forEach((opt, idx) => {
                const isTruth = opt.isReal;
                const authorName = isTruth ? "האמת!" : (data.players[opt.playerId]?.nickname || "לא ידוע");

                // Collect voters
                let votersHtml = '<div class="result-voters">';
                for (const [pid, choice] of Object.entries(data.votes)) {
                    if (choice === idx && data.players[pid]) {
                        // Find this player's index in currentPlayers to get color
                        // We can't rely on 'i' from renderPlayerSlots loop easily unless we search.
                        // Or just assign color based on ID hash or something consistent?
                        // The prompt says: "match the avatar color".
                        // Avatar color in renderPlayerSlots is: AVATAR_COLORS[i % LENGTH]
                        // where 'i' is the index in currentPlayers array.
                        const pIndex = currentPlayers.findIndex(p => p.id === pid);
                        const color = (pIndex >= 0) ? AVATAR_COLORS[pIndex % AVATAR_COLORS.length] : '#999';

                        votersHtml += `<span class="voter-badge" style="background-color: ${color};">${data.players[pid].nickname}</span>`;
                    }
                }
                votersHtml += '</div>';

                stackHtml += `
                    <div class="result-card ${isTruth ? 'truth' : ''}">
                        <div class="result-card-content">
                            <div class="result-text">
                                ${opt.text}
                                ${isTruth ? '<span class="truth-indicator">אמת!</span>' : ''}
                            </div>
                            <div class="result-author">
                                ${isTruth ? 'מערכת פייק מייקר' : 'מאת: ' + authorName}
                            </div>
                        </div>
                        ${votersHtml}
                    </div>
                `;
            });
            stackHtml += '</div>';

            const btnText = data.isLastStep ? "לטבלת הניקוד" : "לשאלה הבאה";

            setGameContent(`
                <div class="reveal-header-split">
                    <div class="reveal-text-area">
                        <div class="reveal-badge">${randomExc}</div>
                        <div class="reveal-headline">
                            ${fullHeadline}
                            ${sourceHtml}
                        </div>
                    </div>
                    <div class="reveal-media-area">
                        <div class="lobby-media-placeholder short"></div>
                    </div>
                </div>
                
                ${stackHtml}
                
                <button class="action-btn" onclick="nextPhase()">${btnText}</button>
            `);
        });

        socket.on('show_leaderboard', () => {
            const sorted = [...currentPlayers].sort((a, b) => b.score - a.score);

            let listHtml = '<div style="width: 60%;">';
            sorted.forEach((p, i) => {
                listHtml += `
                    <div style="display:flex; justify-content:space-between; background:#f9f9f9; padding:10px; border-bottom:1px solid #ddd; font-size:1.5rem; font-weight:bold;">
                        <span>#${i + 1} ${p.nickname}</span>
                        <span style="color:var(--color-purple)">${p.score}</span>
                    </div>
                 `;
            });
            listHtml += '</div>';

            setGameContent(`
                <h2 class="phase-title">המובילים!</h2>
                ${listHtml}
                <button class="action-btn" onclick="startGame()">סיבוב חדש</button>
             `);
        });

    </script>
</body>

</html>